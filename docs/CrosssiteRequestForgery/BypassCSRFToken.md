---
layout: default
title: Bypassing the CSRF token validation
parent: Cross-site Request Forgery
nav_order: 1
has_children: false
---

### What is CSRF token?

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

### How CSRF token help against CSRF attacks?

CSRF token will be generated and sent to the client by the server. 

Let us consider, the application has the form, which updates the email of the user. This form element contains hidden input element which contains CSRF token. 

The Form will look like:

    <form name="update_email" action="/email/update" method="POST">
        <label>Email</label>
        <input type="email" name="email" value="chanukya@target.com">
        <input type="hidden" name="csrf" value="AS12rAeRTascrGrS4ArR4SFGSesdIO">
        <button class="button" type="submit"> Update email </button>
    </form>

> Note: Here the CSRF token is provided in the form with hidden input field. But it may or may not be the case for implementing CSRF.

Now on clicking the submit button, the POST HTTP request will be sent to server which contains the email and CSRF token in the body of the request.

The HTTP request will look like:

    POST /email/update HTTP/1.1
    Host: target.com
    Content-Length: 80
    Content-Type: application/x-www-form-urlencoded
    Cookie: session=DfghgsgtteuyfgFAHdschgnEuIxhasN
    
    csrf=AS12rAeRTascrGrS4ArR4SFGSesdIO&email=chanukyaaaa@target.com

If the implementation of CSRF token is flawless, then it makes difficult for an attacker to construct a valid request on behalf of the victim. As the attacker has no way of predicting the correct value for the CSRF token, they won't be able to include it in the malicious request. 

### Flaws in CSRF token implementation

**Validation of CSRF token depends on token just being present**

Some applications will just check whether the CSRF token is present or not rather than validating the token against correct CSRF token. 

In this case, the attacker will just send some random token and bypass the validation.

**Validation of CSRF token depends on token being present**

Some applications correctly validate the token when it is present but skip the validation if the token is omitted. In this case, it will be easy for the attacker to remove the token and proceed with the attack. 

**Validation of CSRF token depends on request method**

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

In this situation, the attacker can switch to the GET method to bypass the validation and deliver a CSRF attack. The above request after converting to GET method will look like:

    GET /email/update?csrf=AS12rAeRTascrGrS4ArR4SFGSesdIO&email=chanukyaaaa@target.com HTTP/1.1
    Host: target.com
    Content-Length: 80
    Cookie: session=DfghgsgtteuyfgFAHdschgnEuIxhasN

**CSRF token is not tied to the user session**

Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

**CSRF token is tied to a non-session cookie**

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

    POST /email/update HTTP/1.1
    Host: target.com
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 80
    Cookie: session=DfghgsgtteuyfgFAHdschgnEuIxhasN; csrfKey=Rd1d2trrAeRTfasctser35IdkdIad2343
    
    csrf=AS12rAeRTascrGrS4ArR4SFGSesdIO&email=chanukyaaaa@target.com

This situation is harder to exploit but is still vulnerable. If the web site contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible. The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.

**CSRF token is simply duplicated in a cookie**

Some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:

    POST /email/update HTTP/1.1
    Host: target.com
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 80
    Cookie: session=DfghgsgtteuyfgFAHdschgnEuIxhasN; csrf=AS12rAeRTascrGrS4ArR4SFGSesdIO
    
    csrf=AS12rAeRTascrGrS4ArR4SFGSesdIO&email=chanukyaaaa@target.com

In this situation, the attacker can again perform a CSRF attack if the web site contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.